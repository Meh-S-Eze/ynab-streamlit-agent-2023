---
description: ARCHITECTURE PRINCIPLES:
globs: 
alwaysApply: true
---
ARCHITECTURE PRINCIPLES:
  CORE-FIRST DEVELOPMENT:
    - Core logic resides in core/ directory
    - CLI and Streamlit serve as thin access layers
    - Core logic should never import from interface layers
    - Maintain clear separation between data models and processing logic
    - Utilize modular code whenever possible with seperation of functions to indivdual files.  Without breaking existing functionality.  Even if this will increase latency. It should be modularized in such a way that it makes it easy for you to understand and modify.

  PYDANTIC AI INTEGRATION:
    - Use Pydantic BaseModel for all data structures
    - Follow the Agent pattern with structured input/output 
    - Define clear tool functions with comprehensive docstrings
    - Use dependency injection pattern for services
    - Create standalone Agents for specific tasks (transactions, categories, analysis)
    - Ensure proper validation of AI-extracted fields before use

  YNAB API BEST PRACTICES:
    - Implement caching for all API responses (@lru_cache where appropriate)
    - Use delta requests when available to reduce API load
    - Implement circuit breakers for fault tolerance
    - Make specific targeted requests rather than broad ones
    - Handle rate limiting and API errors gracefully
    - NEVER ACCESS ANY BUDGETS EXCEPT YNAB_BUDGET_DEV=7c8d67c8-ed70-4ba8-a25e-931a2f294167
    - Implement entity matching to prevent duplicates (payees, categories, etc.)
    - Cache entity IDs to minimize API calls

  NATURAL LANGUAGE TESTING:
    - Test through CLI natural language queries
    - Document example queries for each feature
    - Log comprehensive debugging information
    - Create standard test scenarios to validate functionality
    - Preserve test examples in documentation
    - NEVER EVER Create isolated mock tests that don't require API credentials

  AI MODEL MANAGEMENT:
  gemini-2.0-pro-exp-02-05	Gemini 2.0 Pro	Improved quality, especially for world knowledge, code, and long context	
gemini-2.0-flash-thinking-exp-01-21	Gemini 2.0 Flash Thinking	Reasoning for complex problems, features new thinking capabilities	
    - Centralize prompt management
    - Document system prompts with examples
    - Use consistent temperature settings per task type
    - Implement proper error handling for model responses
    - Extract and validate JSON responses robustly
    - Include diverse examples in prompts to improve output quality
    - Prefer structured JSON outputs over free-form text
    - Version control all prompt changes
    - Never use fallback parsing when AI parsing fails - focus on improving AI parsing instead

  ERROR HANDLING & LOGGING:
    - Log at appropriate levels (DEBUG, INFO, WARNING, ERROR)
    - Include context variables in log messages
    - Provide user-friendly error messages
    - Implement graceful fallbacks for AI components
    - Use circuit breakers for external services
    - Log raw AI inputs and outputs for debugging purposes

  ENVIRONMENT & CONFIGURATION:
    - Use environment variables for all configuration
    - Support separate development and production environments
    - Document required environment variables
    - Provide sensible defaults where possible
    - Validate configuration on startup
    - NEVER OVERWRITE THE .ENV FILE - IT CONTAINS CONFIRMED API KEYS
    - Always use .env for AI model selection - never hardcode or override in application code
    - Verify environment variable loading at application startup